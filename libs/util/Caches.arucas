import Assert from util.Auxilary;
import AsymmetricBiMap from util.Collections;
/*
*   Class Cache - basic Cache object that removes items sequentially
*/
class Cache : Map {
    var map : Map;
    var capacity : Number = 16;
    Cache() : super() {
        this.map = {};
    }
    Cache(capacity : Number) : super() {
        Assert.assert(capacity > 0);
        this.map = {};
        this.capacity = capacity;
    }
    fun put(key, value) {
        if (!this.containsKey(key)) {
            super.put(key, value);
            this.checkCapacity();
        }
        else {
            super.put(key, value);
        }
    }
    fun checkCapacity() {
        if (len(this) <= this.capacity) return;
        keySet = this.getKeys();
        while (len(this) > this.capacity) {
            this.remove(keySet.get(0));
            keySet.remove(0);
        }
    }
    fun clear() {
        this.map.clear();
        this.clear();
    }
}
/**
*   LFU(Least Frequently Used) Cache : counts references for objects, clears by count.
*/
class LFUCache : Cache {
    static fun countRef(k, presentValue) {
        return presentValue + 1;
    }
    var references : AsymmetricBiMap;
    LFUCache() : super() {
        this.references = AsymmetricBiMap.create();
    }
    LFUCache(capacity : Number) : super(capacity) {
        this.references = AsymmetricBiMap.create();
    }

    fun put(key, value) {
        this.references.computeIfPresent(key, 1, LFUCache.countRef);
        super.put(key, value);
    }
    fun checkCapacity() {
        if (len(this) <= this.capacity) return;
        refs = this.references.inverse();
        keySet = refs.getKeys().sort();
        while (len(this) > this.capacity) {
            foreach (refKeys : keySet) {
                foreach (vals : refs.get(refKeys)) {
                    this.remove(vals);
                    if (len(this) <= this.capacity) return;
                }
            }
        }
    }
    fun clear() {
        this.references.clear();
        this.clear();
    }
}