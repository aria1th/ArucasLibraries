/**
 * Builder class for strings, allowing for
 * mutable strings that can be appended to
 */
class StringBuilder {
    /**
     * The actual string value
     */
    var string;

    /**
     * This creates a default StringBuilder
     * with a blank string to start
     */
    StringBuilder() {
        this.string = "";
    }

    /**
     * This creates a StringBuilder
     * with an initialString
     * Parameter - Value (initialValue): the inital value to use as a string
     */
    StringBuilder(initialValue) {
        // Ensure it's a string
        this.string = initialValue.toString();
    }

    /**
     * This allows to to append something 
     * to the front of the string
     * Parameter - Value (value): the value to append
     * Returns - StringBuilder: this StringBuilder
     */
    fun appendPrefix(value) {
        this.string = value.toString() + this.string;
        return this;
    }

    /**
     * This allows to to append something
     * to the end of the string
     * Parameter - Value (value): the value to append
     * Returns - StringBuilder: this StringBuilder
     */
    fun append(value) {
        this.string = this.string + value.toString();
        return this;
    }

    /**
     * Using the + operator does the same as the .append
     * method but allows for more consise syntax
     * Parameter - Value (value): the value to append
     * Returns - StringBuilder: this StringBuilder
     */
    operator + (value) {
        return this.append(value);
    }

    /**
     * This returns the length
     * of the current StringBuilder
     * Returns - Number: the length of the builder
     */
    fun length() {
        return len(this.string);
    }

    /**
     * Gets the immutable string created
     * by the StringBuilder
     * Returns - String: the immutable string
     */
    fun toString() {
        return this.string;
    }
}
class StringUtil{
    /**
    * StringUtil that shows nested Maps and Lists contents
    */
    static fun repeatStr(string, count) {
        retVal = '';
        while (count > 0) {
            retVal = retVal+ string;
            count--;
        }
        return retVal;
    }

    static fun showMap(map) {
        if (StringUtil.checkArgs(map)) {
            return "" + map;
        }
        retVal = '{';
        foreach ( keys : map.getKeys()) {
            if (map.get(keys).instanceOf(Map.type)) {
                retVal = retVal + '\n' + '"'+ keys + '"'+ " : " + StringUtil.showMap(map.get(keys), 1) + ",";
            }
            else if (map.get(keys).instanceOf(List.type)) {
                retVal = retVal + '\n' +'"' + keys + '"'+ " : " + StringUtil.showList(map.get(keys),1) + ",";
            }
            else {
                retVal = retVal + '\n' +'"' + keys + '"'+ " : " + map.get(keys) + ",";
            }
        }
        return retVal + '\n}';
    }
    static fun showMap(map, indent) {
        if (StringUtil.checkArgs(map)) {
            return "" + map;
        }
        retVal = '{';
        foreach ( keys : map.getKeys()) {
            if (map.get(keys).instanceOf(Map.type)) {
                retVal = retVal +  '\n'+ StringUtil.repeatStr('    ' , indent+1) +'"'+ keys + '"'+ " : " + StringUtil.showMap(map.get(keys), indent+1) + ",";
            }
            else if (map.get(keys).instanceOf(List.type)) {
                retVal = retVal +  '\n'+ StringUtil.repeatStr('    ' , indent+1) +'"' + keys + '"'+ " : " + StringUtil.showList(map.get(keys), indent+1) + ",";
            }
            else {
                retVal = retVal +  '\n'+ StringUtil.repeatStr('    ' , indent+1) +'"' + keys + '"'+ " : " + map.get(keys) + ",";
            }
        }
        return retVal +'\n'+ StringUtil.repeatStr('    ' , indent) + '}';
    }
    static fun showList(list) {
        if (StringUtil.checkArgs(list)) {
            return "" + list;
        }
        retVal = '[';
        foreach ( items : list) {
            if (items.instanceof(Map.type)) {
                retVal = retVal + '\n' + StringUtil.showMap(items) + ",";
            }
            else if (items.instanceof(List.type)) {
                retVal = retVal + '\n' + StringUtil.showList(items) + ",";
            }
            else {
                retVal = retVal + '\n' + items + ",";
            }
        }
        return retVal + '\n]';
    }
    static fun showList(list, indent) {
        if (StringUtil.checkArgs(list)) {
            return "" + list;
        }
        retVal = StringUtil.repeatStr('    ' , indent) + '[';
        foreach ( items : list) {
            if (items.instanceof(Map.type)) {
                retVal = retVal + '\n' + StringUtil.repeatStr('    ' , indent+1) +StringUtil.showMap(items) + ",";
            }
            else if (items.instanceof(List.type)) {
                retVal = retVal + '\n' + StringUtil.repeatStr('    ' , indent+1) + StringUtil.showList(items) + ",";
            }
            else {
                retVal = retVal + '\n' + StringUtil.repeatStr('    ' , indent+1) + items + ",";
            }
        }
        return retVal +'\n'+ StringUtil.repeatStr('    ' , indent) + ']';
    }
    static fun checkArgs(iterable) {
        if (iterable.instanceOf(Map.type)) {
            foreach (item : iterable.getValues()) {
                if (item.instanceOf(Map.type) || item.instanceOf(List.type)) {
                    return false;
                }
            }
            return true;
        }
        if (iterable.instanceOf(List.type)) {
            foreach (item : iterable) {
                type = Type.of(item).getName();
                if (item.instanceOf(Map.type) || item.instanceOf(List.type)) {
                    return false;
                }
            }
            return true;
        }
        return true;
    }
}
