// ./src/test/resources/code/test.arucas

import UnsupportedError from util.Errors;

fun unsupported(message: String) {
    throw new UnsupportedError(message);
}

// Functions that cannot be accessed outside of this class
newNode = null;
newNodeIterator = null;

/* private */ {
    class Node {
        var value;
        var next;

        Node(value) {
            this.value = value;
            this.next = null;
        }

        fun toString() {
            return this.value.toString();
        }
    }

    newNode = fun(value) {
        return new Node(value);
    };

    class NodeIterator: Iterator {
        var current;
        NodeIterator(node): super() {
            this.current = node;
        }

        fun hasNext() {
            return this.current != null;
        }

        fun next() {
            current = this.current;
            this.current = current.next;
            return current;
        }
    }

    newNodeIterator = fun(node) {
        return new NodeIterator(node);
    };
}

interface Stack {
    fun isEmpty();

    fun push(value);

    fun pop();

    fun peek();

    fun contains(object);
}

interface Queue {
    fun isEmpty();

    fun enqueue(value);

    fun dequeue();

    fun front();

    fun end();

    fun contains(object);
}

/**
 * Stack data strucutre using linked nodes
 * FIFO with basic methods
 */
class LinkedStack: Collection, Stack {
    /**
     * Size of the stack
     */
    var size: Number = 0;
    /**
     * Current node of the stack
     */
    var current;

    /**
     * Constructs a new LinkedStack
     */
    LinkedStack(): super() {
        this.current = null;
    }

    /**
     * Returns the current size of the collection
     */
    fun size(): Number {
        return this.size;
    }

    /**
     * Checks if the stack is empty
     * Returns - Boolean: whether the stack is empty
     */
    fun isEmpty(): Boolean {
        return this.current == null;
    }

    /**
     * This pushes a new value to the top of the stack
     * Parameter - Value (value): the value to add to the stack
     */
    fun push(value) {
        nextNode = newNode(value);
        nextNode.next = this.current;
        this.current = nextNode;
        this.size++;
    }

    /**
     * This removes the value at the top of the stack
     * Returns - Value: the value that was at the top
     * Throws - Error: Stack is empty
     */
    fun pop(): Object {
        if (this.isEmpty()) {
            throw new Error("Stack is empty");
        }
        currentNode = this.current;
        this.current = this.current.next;
        this.size--;
        return currentNode.value;
    }

    /**
     * This peeks at the value at the top of the stack
     * Returns - Value: the value at the top of stack
     * Throws - Error: Stack is empty
     */
    fun peek(): Object {
        if (this.isEmpty()) {
            throw new Error("Stack is empty");
        }
        return this.current.value;
    }

    fun iterator(): Iterator {
        return newNodeIterator(this.current);
    }

    fun contains(object): Boolean {
        foreach (element : this) {
            if (element == object) {
                return true;
            }
        }
        return false;
    }

    /**
     * Converts the stack to a list,
     * with the top of the stack being first
     * Returns - List: the stack as a list
     */
    fun toList(): List {
        list = [];
        current = this.current;
        while (current != null) {
            list.append(current);
            current = current.next;
        }
        return list;
    }

    /**
     * Creates a string representation
     * of the stack
     * Returns - String: the string representation
     */
    fun toString(): String {
        // Prevents cyclical import
        import StringBuilder from util.StringUtils;
        
        builder = new StringBuilder("Stack{");
        current = this.current;
        while (current != null) {
            builder + current;
            current = current.next;
            if (current != null) {
                builder + ", ";
            }
        }
        return (builder + "}").toString();
    }
}

import StringBuilder from util.StringUtils;

/**
 * Queue data strucutre using linked nodes
 * FILO with basic methods
 */
class LinkedQueue: Collection, Queue {
    /**
     * Size of the queue
     */
    var size: Number = 0;
    /**
     * The node that is at the
     * front of the queue
     */
    var head;
    /**
     * The node that is at the
     * end of the queue
     */
    var tail;

    /**
     * Constructs a new LinkedQueue
     */
    LinkedQueue(): super() {
        this.head = this.tail = null;
    }

    /**
     * Returns the current size of the collection
     */
    fun size(): Number {
        return this.size;
    }

    /**
     * Checks whether the queue is empty
     * Returns - Boolean: whether the queue is empty
     */
    fun isEmpty(): Boolean {
        return this.head == null;
    }

    /**
     * Adds a value to the end of the queue
     * Parameter - Value (value): the value to add to the queue
     */
    fun enqueue(value) {
        nextNode = newNode(value);
        if (this.isEmpty()) {
            this.head = this.tail = nextNode;
        } else {
            this.tail = this.tail.next = nextNode;
        }
        this.size++;
    }

    /**
     * Removes the value at the start of the queue
     * Returns - Value: the value at the start of the queue
     * Throws - Error: Queue is empty
     */
    fun dequeue(): Object {
        if (this.isEmpty()) {
            throw new Error("Queue is empty");
        }
        head = this.head;
        this.head = this.head.next;
        this.size--;
        return head.value;
    }

    /**
     * Gets the value at the front of the queue
     * Returns - Value: the value at the front of the queue
     * Throws - Error: Queue is empty
     */
    fun front(): Object {
        if (this.isEmpty()) {
            throw new Error("Queue is empty");
        }
        return this.head.value;
    }

    /**
     * Gets the value at the end of the queue
     * Returns - Value: the value at the end of the queue
     * Throws - Error: Queue is empty
     */
    fun end(): Object {
        if (this.isEmpty()) {
            throw new Error("Queue is empty");
        }
        return this.tail.value;
    }

    fun iterator(): Iterator {
        return newNodeIterator(this.head);
    }

    fun contains(object): Boolean {
        foreach (element : this) {
            if (element == object) {
                return true;
            }
        }
        return false;
    }

    /**
     * Converts the queue to a list,
     * with the start of the queue being first
     * Returns - List: the queue as a list
     */
    fun toList(): List {
        list = [];
        head = this.head;
        while (head != null) {
            list.append(head);
            head = head.next;
        }
        return list;
    }

    /**
     * Creates a string representation
     * of the queue
     * Returns - String: the string representation
     */
    fun toString(): String {
        builder = new StringBuilder("Queue{");
        head = this.head;
        while (head != null) {
            builder + head;
            head = head.next;
            if (head != null) {
                builder + ", ";
            }
        }
        return (builder + "}").toString();
    }
}

/**
 * Deque class that acts as both a Stack and a Queue.
 * It can be iterated over in both directions.
 */
class Deque: Collection, Stack, Queue {
    var list = [];

    Deque(): super();

    /**
     * Returns the size of the deque
     */
    fun size(): Number {
        return len(this.list);
    }

    /**
     * Returns whether the deque is empty
     */
    fun isEmpty(): Boolean {
        return this.size() == 0;
    }

    /**
     * Pushes a value to the end of the deque (top of the stack)
     */
    fun push(value: Object) {
        this.list.append(value);
    }

    /**
     * Pops a value off the end of the deque (top of the stack)
     */
    fun pop(): Object {
        this.throwIfEmpty("Cannot pop an empty stack");
        return this.list.remove(this.size() - 1);
    }

    /**
     * Peeks at the end of the deque (top of the stack)
     */
    fun peek(): Object {
        this.throwIfEmpty("Cannot peek an empty stack");
        return this.list[this.size() - 1];
    }

    /**
     * Enqueues a value to the end of the deque (end of the queue)
     */
    fun enqueue(value: Object) {
        this.push(value);
    }

    /**
     * Dequeues a value from the front of the deque (front of the queue)
     */
    fun dequeue(): Object {
        this.throwIfEmpty("Cannot dequeue an empty queue");
        return this.list.remove(0);
    }

    /**
     * Peeks at the front of the deque (front of the queue)
     */
    fun front(): Object {
        this.throwIfEmpty("Cannot peek an empty queue");
        return this.list[0];
    }

    /**
     * Peeks at the end of the deque (end of the queue)
     */
    fun end(): Object {
        this.throwIfEmpty("Cannot peek an empty queue");
        return this.peek();
    }

    /**
     * Gets the iterator for the deque, in the order of a queue.
     * First item will be at the start of the deque.
     */
    fun iterator(): Iterator {
        return this.list.iterator();
    }

    /**
     * Gets the iterator for the deque, in the order of a stack.
     */
    fun reverseIterator(): Iterator {
        return this.list.copy().reverse().iterator();
    }

    fun contains(object): Boolean {
        return this.list.contains(object);
    }

    fun throwIfEmpty(message: String) {
        if (this.isEmpty()) {
            throw new Error(message);
        }
    }

    fun toString(): String {
        builder = new StringBuilder("Deque{");
        iter = this.iterator();
        while (iter.hasNext()) {
            next = iter.next();
            builder.append(next.toString());
            if (iter.hasNext()) {
                builder.append(", ");
            }
        }
        return (builder + "}").toString();
    }

    operator [] (index: Number) {
        return this.list[index];
    }
}

/**
 * Immutable List implementation.
 * List that cannot be modified.
 */
class ImmutableList: List {
    static var EMPTY = ImmutableList.of();

    ImmutableList(values: Iterable): super() {
        foreach (value : values) {
            super.append(value);
        }
    }

    fun set(object: Object, index: Number) unsupported("Cannot set in an immutable list");

    fun remove(index: Number) unsupported("Cannot remove from an immutable list");

    fun append(object: Object) unsupported("Cannot append to an immutable list");

    fun prepend(object: Object) unsupported("Cannot prepend to an immutable list");

    fun insert(object: Object, index: Number) unsupported("Cannot insert to an immutable list");

    fun addAll(collection: Collection) unsupported("Cannot add all to an immutable list");

    fun removeAll(collection: Collection) unsupported("Cannot remove all from an immutable list");

    fun retainAll(collection: Collection) unsupported("Cannot retain all from an immutable list");

    fun clear() unsupported("Cannot clear an immutable list");

    fun sort() unsupported("Cannot sort an immutable list");

    fun sort(comparator: Function) unsupported("Cannot sort an immutable list");

    fun reverse() unsupported("Cannot reverse an immutable list");

    fun shuffle() unsupported("Cannot shuffle an immutable list");

    fun copy() {
        return this;
    }

    fun copyMutable() {
        return [].addAll(this);
    }

    operator [] (index, value) {
        return this.set(value, index);
    }

    static fun of(values...): ImmutableList {
        return new ImmutableList(values);
    }
}

class ImmutableSet: Set {
    static var EMPTY = ImmutableSet.of();

    ImmutableSet(values: Iterable): super() {
        foreach (value : values) {
            super.add(value);
        }
    }

    fun add(value: Object) unsupported("Cannot add to an immutable set");

    fun addAll(collection: Collection) unsupported("Cannot add to an immutable set");

    fun remove(value: Object) unsupported("Cannot remove from an immutable set");

    fun removeAll(collection: Collection) unsupported("Cannot remove from an immutable set");

    fun clear() unsupported("Cannot clear an immutable set");

    static fun of(values...): ImmutableSet {
        return new ImmutableSet(values);
    }
}

class ImmutableMap: Map {
    static var EMPTY = ImmutableMap.of();

    ImmutableMap(map: Map): super() {
        super.putAll(map);
    }

    fun clear() unsupported("Cannot clear an immutable map");

    fun put(key, value) unsupported("Cannot put into an immutable map");

    fun putAll(map) unsupported("Cannot put into an immutable map");

    fun putIfAbsent(key, value) unsupported("Cannot put into an immutable map");

    fun remove(key) unsupported("Cannot remove from an immutable map");

    operator [] (index, value) {
        return this.put(index, value);
    }

    static fun of(args...): ImmutableMap {
        size = len(args);
        if (Math.mod(size, 2) != 0) {
            throw new Error("Expected even amount of arguments; (key, value) pairs");
        }
        map = {};
        for (local i = 0; i < size; i++) {
            map[args[i]] = args[i++];
        }
        return new ImmutableMap(map);
    }
}

class DefaultedMap: Map {
    var defaultValue = null;

    DefaultedMap(): super();

    DefaultedMap(defaultValue): super() {
        this.defaultValue = defaultValue;
    }

    DefaultedMap(items, defaultValue) : super() {
        this.defaultValue = defaultValue;
        foreach (item : items) {
            this.put(item, this.defaultValue);
        }
    }

    static fun createFrom(iterable : Iterable, defaultValue) {
        map = new DefaultedMap(defaultValue);
        map.addAll(iterable);
        return map;
    }

    fun addAll(values : Iterable) {
        foreach (item : values) {
            this.put(item, this.defaultValue);
        }
    }
    fun addAll(values : Iterable, specificValue : Object) {
        foreach (item : values) {
            this.put(item, specificValue);
        }
    }
    
    fun put(key) {
        return this.put(key, this.defaultValue);
    }

    fun poll() {
        if (!this.isEmpty()) {
            return this.getKeys().get(0);
        }
        return null;
    }

    fun get(key) {
        value = super.get(key);
        if (value == null) {
            return this.defaultValue;
        }
        return value;
    }
}


/**
*   class BiMap : BiMap contains key, value pair as {a : val1, ...}, {val1 : a}
*   offers inverse() method to get view of inverted BiMap
*   throws IllegalArgumentError when duplicate key-value pair is inputed
**/
class BiMap : Map {
    var original : Map;
    var backend : Map;
        BiMap() : super() {
            this.original = {};
            this.backend = {};
        }
        BiMap(arg1, arg2) : super() {
            this.original = arg1;
            this.backend = arg2;
        }
    /**
    * create new BiMap
    **/
    static fun create() {
        return new BiMap();
    }

    /**
    * create new BiMap that references reverse view of dictionary. Change is reflected in original BiMap too.
    **/
    fun inverse() {
        return new BiMap(this.backend, this.original);
    }

    /**
    * replace existing entries and assign new key:value pair
    **/
    fun forcePut(key, value) {
        this.original.remove(key);
        this.backend.remove(value);
        this.put(key, value);
    }

    /**
    * overrides Iterable.iterator() method.
    **/
    fun iterator() {
        return this.original.iterator();
    }

    /**
    * overrides Map.put() method, BiMap only allows unique connection between key <-> value.
    **/
    fun put(key, value) {
        if (this.original.containsKey(key)) {
            if (value != this.original.get(key)) {
                throw new IllegalArgumentError("Cannot input duplcate key " + key + " for value : "+ value + ", use BiMap.forcePut(key, value) to replace!");
            }
        }
        if (this.backend.containsKey(value)) {
            if (key != this.backend.get(value)) {
                throw new IllegalArgumentError("Cannot input duplcate value " + value + " for key : "+ key + ", use BiMap.forcePut(key, value) to replace!");
            }
        }
        this.original.put(key, value);
        this.backend.put(value, key);
    }

    /**
    * overrides Map.putIfAbsent() method.
    **/
    fun putIfAbsent(key, value) {
        if (this.original.containsKey(key)) {
            return false;
        }
        if (this.backend.containsKey(value)) {
            return false;
        }
        this.put(key, value);
        return true;
    }
    /**
    * BiMap.computeIfPresent(k, v, mappingFunction(k, v)) -> if (k,ev) is present, compute mappedValue from mappingFunction(k, ev), then replaces (k,ev) with (k, mappedValue).
    * returns mappedValue assigned to k.
    **/
    fun computeIfPresent(key, defaultValue, mappingFunction) {
        if (this.original.containsKey(key)) {
            mv = mappingFunction(key, this.original.get(key));
            this.remove(key);
            this.put(key, mv);
            return mv;
        }
        else {
            this.put(key, defaultValue);
        }
        return defaultValue;
    }
    /**
    * offers forcePutAll(another Map) method, removes all duplicate connections and puts values.
    **/
    fun forcePutAll(another : Map) {
        foreach (key : another.getKeys()) {
            this.forcePut(key, another.get(key));
        }
    }

    /**
    * common methods for Map
    **/
    fun containsKey(key : Object) {
        return this.original.containsKey(key);
    }

    fun containsValue(value : Object) {
        return this.backend.containsKey(value);
    }

    fun get(k) {
        return this.original.get(k);
    }

    fun getKeys() {
        return this.original.getKeys();
    }

    fun getValues() {
        return this.backend.getValues();
    }

    fun clear() {
        this.original.clear();
        this.backend.clear();
    }

    fun map(arg) {
        return this.original.map(arg);
    }

    fun remove(k) {
        if (this.original.containsKey(k)){
            v = this.original.get(k);
            this.original.remove(k);
            this.backend.remove(v);
            return true;
        }
        return false;
    }
}

/**
*   class MultiBiMap : BiMap contains key, value pair as {a : {val1, val2, ...}}, {val1 : {a, b, ...}}
*   offers inverse() method to get view of inverted BiMap
**/

class MultiBiMap : BiMap {
    static var DEFAULT = fun (){return null;}; //create lambda function for unique object that does not overlap other.
    MultiBiMap() : super() {}
    MultiBiMap(arg1, arg2) : super(arg1, arg2) {}

    static fun create() {
        return new MultiBiMap();
    }

    /**
    * overrides put(key, value) in BiMap, mapped results are now assigned as Set.
    * put(k, v, ?r) replaces existing value.
    **/
    fun put(args...) {
        if (len(args) < 2) throw new AssertionError("Argument length for MultiBiMap.put() should be at least 2!");
        key = args.get(0);
        value = args.get(1);
        replace = MultiBiMap.DEFAULT;
        if (len(args) >= 3) replace = args.get(2);
        if (replace != MultiBiMap.DEFAULT) {
            this.remove(key, replace);
        }
        if (this.original.containsKey(key)) {
            this.original.get(key).add(value);
        }
        else {
            this.original.put(key, Set.of(value));
        }
        if (this.backend.containsKey(value)) {
            this.backend.get(value).add(key);
        }
        else {
            this.backend.put(value, Set.of(key));
        }
    }

    /**
    * MultiBiMap does not support removing from remove(k), instead call remove(k, v)
    **/
    fun remove(k) unsupported("method remove(k) is ambiguous; call remove(k,v) for MultiBiMap!");
    fun remove(key, value) {
        keySet = this.original.get(key);
        if (keySet != null) keySet.remove(value);
        if (keySet.isEmpty()) this.original.remove(key);
        valueSet = this.backend.get(value);
        if (valueSet != null) valueSet.remove(key);
        if (valueSet.isEmpty()) this.backend.remove(value);
        return !keySet.isEmpty() && !valueSet.isEmpty();
    }
    /**
    * forcePut(k, v) and forcePutAll(another Map) is unsupported : multiBiMap has multiple entries at default. for replacing existing values, use put(k, v, ?r)
    **/
    fun forcePut(key, value) unsupported("method forcePut is not available for MultiBiMap!");
    fun forcePutAll(arg) unsupported("method forcePutAll is not available for MultiBiMap!");

    /**
    * MultiBiMap.containsPair(k,v) returns true if correct pair of k,v exists.
    **/
    fun containsPair(k, v) {
        keySet = this.original.get(k);
        return keySet != null && keySet.contains(v);
    }

    fun inverse() {
        return new MultiBiMap(this.backend, this.original);
    }
}
/**
*   class AsymmetricBiMap : BiMap which allows (k1, k2, k3...) -> v1, but not (v1, v2, v3...) -> k1.
*   offers inverse() method, but put() method will not work anymore.
**/

class AsymmetricBiMap : BiMap {
    static var DEFAULT = fun (){return null;}; //create lambda function for unique object that does not overlap other.
    var inverted = false;
        AsymmetricBiMap() : super() {}
        AsymmetricBiMap(arg1, arg2, inverse) : super(arg1, arg2) {
            this.inverted = inverse;
        }

    static fun create() {
        return new AsymmetricBiMap();
    }

    /**
    * overrides put(key, value) in BiMap, mapped results are now assigned as Set.
    * put(k, v, ?r) replaces existing value.
    **/
    fun put(key, value) {
        if (this.inverted) unsupported("Cannot invoke method put(k,v) for inverted AsymmetricBiMap");
        if (this.original.containsKey(key)) {
            throw new IllegalArgumentError("Cannot input duplcate key " + key + " for value : "+ value + ", use BiMap.forcePut(key, value) to replace!");
        }
        else {
            this.original.put(key, value);
        }
        if (this.backend.containsKey(value)) {
            this.backend.get(value).add(key);
        }
        else {
            this.backend.put(value, Set.of(key));
        }
    }

    /**
    * overrides put(key, value) in BiMap, mapped results are now assigned as Set.
    * put(k, v, ?r) replaces existing value.
    **/
    fun forcePut(key, value) {
        if (this.inverted) unsupported("Cannot invoke method put(k,v) for inverted AsymmetricBiMap");
        if (this.original.containsKey(key)) {
            this.remove(key);
        }
        this.put(key, value);
    }

    /**
    * removes key -> value connection from AsymmetricBiMap
    **/
    fun remove(k) {
        if (this.inverted) unsupported("Cannot invoke method remove(k) for inverted AsymmetricBiMap");
        if (this.original.containsKey(k)) {
            v = this.original.get(k);
            this.original.remove(k);
            valueSet = this.backend.get(v);
            valueSet.remove(k);
            if (valueSet.isEmpty()) this.backend.remove(v);
            return true;
        }
        return false;
    }

    /**
    * AsymmetricBiMap.containsPair(k,v) returns true if correct pair of k,v exists.
    **/
    fun containsPair(k, v) {
        if (this.inverted) unsupported("Cannot invoke method containsPair(k,v) for inverted AsymmetricBiMap");
        return this.original.containsKey(k) && v == this.original.get(k);
    }

    /**
    * AsymmetricBiMap.computeIfPresent(k, v, mappingFunction(k, v)) -> if (k,?ev) is present, compute mappedValue from mappingFunction(k, ev), then replaces (k,ev) with (k, mappedValue). else, put (k,v).
    * returns mappedValue assigned to k.
    **/
    fun computeIfPresent(key, defaultValue, mappingFunction) {
        if (this.inverted) unsupported("Cannot invoke method compute(k,v,f) for inverted AsymmetricBiMap");
        return super.computeIfPresent(key, defaultValue, mappingFunction);
    }

    fun inverse() {
        return new AsymmetricBiMap(this.backend, this.original, !this.inverted);
    }
}